# 02 | 代码加锁：不要让“锁”事成为烦心事

1. 加锁前要清楚锁和被保护的对象是不是一个层面的

   <u>静态字段属于类</u>，类级别的锁才能保护；而<u>非静态字段属于类实例</u>，实例级别的锁就可以保护。

   ```java
   class Data {
       @Getter
       private static int counter = 0;
       
       public static int reset() {
           counter = 0;
           return counter;
       }
   
       public synchronized void wrong() {
           counter++;
       }
   }
   
   // 调用
   IntStream.rangeClosed(1, 100).parallel().forEach(i -> new Data().wrong());
   ```

   多线程调用，最后的结果并不会等于100。非静态的wrong方法上加锁，只能确保多个线程无法执行同一个实例wrong方法。但是不能保证不会执行不同的实例wrong方法。解决方法就是添加一个静态对象，并为静态对象加锁。

   ```java
   class Data {
       @Getter
       private static int counter = 0;
       private static Object locker = new Object();
   
       public void right() {
           synchronized (locker) {
               counter++;
           }
       }
   }
   ```

   也可以把wrong方法改成static，但是这样不好，不能因为解决线程问题而改变代码结构。

2. 加锁要考虑锁的粒度和场景问题

   - 即使我们确实有一些共享资源需要保护，也要尽可能降低锁的粒度，仅对必要的代码块甚至是需要保护的资源本身加锁。而不是大段大段的加锁。

   - 如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：<u>区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁</u>。 

   建议：

   - 对于读写比例差异明显的场景，考虑使用 ReentrantReadWriteLock 细化区分读写锁，来提高性能。
   - 如果你的 JDK 版本高于 1.8、共享资源的冲突概率也没那么大的话，考虑使用 StampedLock 的乐观读的特性，进一步提高性能。
   - JDK 里 ReentrantLock 和 ReentrantReadWriteLock 都提供了公平锁的版本，在没有明确需求的情况下不要轻易开启公平锁特性，在任务很轻的情况下开启公平锁可能会让性能下降上百倍。

3. 多把锁要小心死锁问题

   案例：

   ​	下单操作需要<u>锁定订单中多个商品的库存，拿到所有商品的锁</u>之后进行下单扣减库存操作，全部操作完成之后释放所有的锁。代码上线后发现，下单失败概率很高，失败后需要用户重新下单，极大影响了用户体验，还影响到了销量。

   造成的原因是因为一个购物车里有item1和item2，另一个购物车有item2和item1，一个线程获取item1的锁，另一个获取了item2的锁，那么就会造成死锁。

   避免这个问题的方法就是，为购物车里的商品排序，让所有的线程先获取item1，在获取item2。

   

总结：

- 第一，使用 synchronized 加锁虽然简单，但我们首先要弄清楚共享资源是类还是实例级别的、会被哪些线程操作，synchronized 关联的锁对象或方法又是什么范围的。
- 第二，加锁尽可能要考虑粒度和场景，锁保护的代码意味着无法进行多线程操作。对于 Web 类型的天然多线程项目，对方法进行大范围加锁会显著降级并发能力，要考虑尽可能地只为必要的代码块加锁，降低锁的粒度；而对于要求超高性能的业务，还要细化考虑锁的读写场景，以及悲观优先还是乐观优先，尽可能针对明确场景精细化加锁方案，可以在适当的场景下考虑使用 ReentrantReadWriteLock、StampedLock 等高级的锁工具类。
- 第三，业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是，避免无限等待和循环等待。
- 最后，如果业务逻辑中锁的实现比较复杂的话，要仔细<u>看看加锁和释放是否配对</u>，是否有遗漏释放或重复释放的可能性；并且对于<u>分布式锁要考虑锁自动超时释放了，而业务逻辑却还在进行的情况下，如果别的线线程或进程拿到了相同的锁，可能会导致重复执行</u>。